import 'reflect-metadata';
import { IScope } from './scope';
import { ITransformer } from './mapper';
import { Class } from './utils';
/**
 * Used to mark a class as a decorator, it is required in order to be able to be mapped by the buildMapper function.
 * It has to annotate the exact class used by buildMapper and is not inherited.
 *
 * @return ClassDecorator
 */
export declare const dto: () => ClassDecorator;
/**
 * Used to mark a field of a dto, fields not decorated by @include will not be included in the mapper
 *
 * @return PropertyDecorator
 */
export declare const include: () => PropertyDecorator;
/**
 * Used to make a field only usable if a specific scope has been provided to the mapper.
 * Can be used to restrict data depending on permissions, for example admin only properties.
 *
 * @param scopes The scopes that can access this field.
 * @return PropertyDecorator
 */
export declare const scope: (...scopes: IScope[]) => PropertyDecorator;
/**
 * Used to map the field to a field named differently on the entity class
 *
 * @param to The name of the field it is mapped to on the entity class
 * @return PropertyDecorator
 */
export declare const mapTo: (to: string) => PropertyDecorator;
/**
 * Used to provide a transformer to transform the field when it is serialized / deserialized
 *
 * @example @transform({ toDto: (input: Date) => input.getTime(), fromDto: (input: Date) => new Date(input) })
 *
 *
 * @param transformer The transformer to be used
 * @return PropertyDecorator
 */
export declare const transform: (transformer: ITransformer<any, any>) => PropertyDecorator;
export interface INestedMetadata {
    accessor: () => Class<any>;
    many: boolean;
}
/**
 * Used to map this property to another Dto
 *
 * @param accessor A function that returns the class to use to map the nested dto, should also be decorated by @dto
 * @param many Whether this field is an array or not
 * @return PropertyDecorator
 */
export declare const nested: (accessor: () => Class<any>, many?: boolean) => PropertyDecorator;
export declare enum AccessMode {
    NONE = 0,
    READ = 1,
    WRITE = 2,
    ALL = 3
}
/**
 * Used to define the if this property should be serializable / deserializable
 *
 * @param mode The access mode, 0 = None, 1 = Serialize, 2 = Deserialize, 3 = Both
 * @return PropertyDecorator
 */
export declare const accessMode: (mode: AccessMode) => PropertyDecorator;
/**
 * Used to make this property serialize only
 *
 * @return PropertyDecorator
 */
export declare const readOnly: () => PropertyDecorator;
/**
 * Used to make this property deserialize only
 *
 * @return PropertyDecorator
 */
export declare const writeOnly: () => PropertyDecorator;
