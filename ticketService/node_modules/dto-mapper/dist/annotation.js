"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeOnly = exports.readOnly = exports.accessMode = exports.AccessMode = exports.nested = exports.transform = exports.mapTo = exports.scope = exports.include = exports.dto = void 0;
require("reflect-metadata");
const const_1 = require("./const");
/**
 * Used to mark a class as a decorator, it is required in order to be able to be mapped by the buildMapper function.
 * It has to annotate the exact class used by buildMapper and is not inherited.
 *
 * @return ClassDecorator
 */
const dto = () => {
    return (target) => {
        Reflect.defineMetadata(const_1.DTO_METADATA, true, target);
    };
};
exports.dto = dto;
/**
 * Used to mark a field of a dto, fields not decorated by @include will not be included in the mapper
 *
 * @return PropertyDecorator
 */
const include = () => {
    return (target, propertyKey) => {
        const properties = Reflect.getMetadata(const_1.PROPERTIES_METADATA, target.constructor) || [];
        if (!properties.includes(propertyKey)) {
            Reflect.defineMetadata(const_1.PROPERTIES_METADATA, [...properties, propertyKey], target.constructor);
        }
    };
};
exports.include = include;
/**
 * Used to make a field only usable if a specific scope has been provided to the mapper.
 * Can be used to restrict data depending on permissions, for example admin only properties.
 *
 * @param scopes The scopes that can access this field.
 * @return PropertyDecorator
 */
const scope = (...scopes) => {
    return (target, propertyKey) => {
        const definedScopes = Reflect.getMetadata(const_1.SCOPE_METADATA, target.constructor, propertyKey) || [];
        Reflect.defineMetadata(const_1.SCOPE_METADATA, [...definedScopes, ...scopes], target.constructor, propertyKey);
    };
};
exports.scope = scope;
/**
 * Used to map the field to a field named differently on the entity class
 *
 * @param to The name of the field it is mapped to on the entity class
 * @return PropertyDecorator
 */
const mapTo = (to) => {
    return (target, propertyKey) => {
        Reflect.defineMetadata(const_1.MAP_TO_METADATA, to, target.constructor, propertyKey);
    };
};
exports.mapTo = mapTo;
/**
 * Used to provide a transformer to transform the field when it is serialized / deserialized
 *
 * @example @transform({ toDto: (input: Date) => input.getTime(), fromDto: (input: Date) => new Date(input) })
 *
 *
 * @param transformer The transformer to be used
 * @return PropertyDecorator
 */
const transform = (transformer) => {
    return (target, propertyKey) => {
        const definedTransformers = Reflect.getMetadata(const_1.TRANSFORM_METADATA, target.constructor, propertyKey) || [];
        Reflect.defineMetadata(const_1.TRANSFORM_METADATA, [...definedTransformers, transformer], target.constructor, propertyKey);
    };
};
exports.transform = transform;
/**
 * Used to map this property to another Dto
 *
 * @param accessor A function that returns the class to use to map the nested dto, should also be decorated by @dto
 * @param many Whether this field is an array or not
 * @return PropertyDecorator
 */
const nested = (accessor, many = false) => {
    return (target, propertyKey) => {
        const meta = {
            accessor,
            many,
        };
        Reflect.defineMetadata(const_1.NESTED_METADATA, meta, target.constructor, propertyKey);
    };
};
exports.nested = nested;
var AccessMode;
(function (AccessMode) {
    AccessMode[AccessMode["NONE"] = 0] = "NONE";
    AccessMode[AccessMode["READ"] = 1] = "READ";
    AccessMode[AccessMode["WRITE"] = 2] = "WRITE";
    AccessMode[AccessMode["ALL"] = 3] = "ALL";
})(AccessMode = exports.AccessMode || (exports.AccessMode = {}));
/**
 * Used to define the if this property should be serializable / deserializable
 *
 * @param mode The access mode, 0 = None, 1 = Serialize, 2 = Deserialize, 3 = Both
 * @return PropertyDecorator
 */
const accessMode = (mode) => {
    return (target, propertyKey) => {
        Reflect.defineMetadata(const_1.ACCESS_MODE_METADATA, mode, target.constructor, propertyKey);
    };
};
exports.accessMode = accessMode;
/**
 * Used to make this property serialize only
 *
 * @return PropertyDecorator
 */
const readOnly = () => {
    return (target, propertyKey) => {
        Reflect.defineMetadata(const_1.ACCESS_MODE_METADATA, AccessMode.READ, target.constructor, propertyKey);
    };
};
exports.readOnly = readOnly;
/**
 * Used to make this property deserialize only
 *
 * @return PropertyDecorator
 */
const writeOnly = () => {
    return (target, propertyKey) => {
        Reflect.defineMetadata(const_1.ACCESS_MODE_METADATA, AccessMode.WRITE, target.constructor, propertyKey);
    };
};
exports.writeOnly = writeOnly;
