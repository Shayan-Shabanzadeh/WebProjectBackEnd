import { IScope } from './scope';
import { Class } from './utils';
export interface IResolvedFieldValue<ClassT> {
    key: keyof ClassT;
    value: ClassT[keyof ClassT];
}
export interface IMapper<DtoT, EntityT> {
    deserialize(input: DtoT, scope?: IScope): EntityT;
    serialize(input: EntityT, scope?: IScope): DtoT;
    deserialize<T = null | undefined>(input: T, scope?: IScope): T;
    serialize<T = null | undefined>(input: T, scope?: IScope): T;
    deserializeAndMapField<KeyT extends keyof DtoT>(key: KeyT, input: DtoT[KeyT], scope?: IScope): IResolvedFieldValue<EntityT> | undefined;
    serializeAndUnmapField<KeyT extends keyof EntityT>(key: KeyT, input: EntityT[KeyT], scope?: IScope): IResolvedFieldValue<DtoT> | undefined;
    deserializeField<KeyT extends keyof DtoT>(key: KeyT, input: DtoT[KeyT], scope?: IScope): EntityT[keyof EntityT] | undefined;
    serializeField<KeyT extends keyof EntityT>(key: KeyT, input: EntityT[KeyT], scope?: IScope): DtoT[keyof DtoT] | undefined;
    mapKey<KeyT extends keyof DtoT>(key: KeyT, scope?: IScope): keyof EntityT | undefined;
    unmapKey<KeyT extends keyof EntityT>(key: KeyT, scope?: IScope): keyof DtoT | undefined;
}
export declare type ITransformFunction<InT, OutT> = (input: InT, scope?: IScope) => OutT;
export interface ITransformer<DtoFieldT, EntityFieldT> {
    readonly fromDto: ITransformFunction<DtoFieldT, EntityFieldT>;
    readonly toDto: ITransformFunction<EntityFieldT, DtoFieldT>;
}
export interface IMapperField<DtoKeyT extends keyof DtoT = any, EntityKeyT extends keyof EntityT = any, DtoT = any, EntityT = any> {
    readonly from: DtoKeyT;
    readonly to: EntityKeyT;
    readonly scopes?: readonly IScope[];
    readonly disableSerialize?: boolean;
    readonly disableDeserialize?: boolean;
    readonly transformer?: ITransformer<DtoT[DtoKeyT], EntityT[EntityKeyT]>;
}
export interface IMapperConfig<DtoT, EntityT> {
    readonly dtoConstructor?: Class<DtoT>;
    readonly entityConstructor?: Class<EntityT>;
    readonly fields: IMapperField<keyof DtoT, keyof EntityT, DtoT, EntityT>[];
}
declare type IFieldMap<DtoT, EntityT> = {
    readonly [KeyT in keyof DtoT]?: IMapperField<KeyT, keyof EntityT, DtoT, EntityT>;
};
declare type IReverseFieldMap<DtoT, EntityT> = {
    readonly [KeyT in keyof EntityT]?: IMapperField<keyof DtoT, KeyT, DtoT, EntityT>;
};
export declare class Mapper<DtoT, EntityT> implements IMapper<DtoT, EntityT> {
    readonly config: IMapperConfig<DtoT, EntityT>;
    readonly fieldMap: IFieldMap<DtoT, EntityT>;
    readonly reverseFieldMap: IReverseFieldMap<DtoT, EntityT>;
    constructor(config: IMapperConfig<DtoT, EntityT>);
    private deserializeFieldInternal;
    private serializeFieldInternal;
    deserialize(input: DtoT, scope?: IScope): EntityT | null | undefined;
    serialize(input: EntityT, scope?: IScope): DtoT | null | undefined;
    deserializeField<KeyT extends keyof DtoT>(key: KeyT, input: DtoT[KeyT], scope?: IScope): EntityT[keyof EntityT] | undefined;
    serializeField<T, KeyT extends keyof EntityT>(key: KeyT, input: EntityT[KeyT], scope?: IScope): DtoT[keyof DtoT] | undefined;
    mapKey<KeyT extends keyof DtoT>(key: KeyT, scope?: IScope): keyof EntityT | undefined;
    unmapKey<KeyT extends keyof EntityT>(key: KeyT, scope?: IScope): keyof DtoT | undefined;
    deserializeAndMapField<KeyT extends keyof DtoT>(key: KeyT, input: DtoT[KeyT], scope?: IScope): IResolvedFieldValue<EntityT> | undefined;
    serializeAndUnmapField<KeyT extends keyof EntityT>(key: KeyT, input: EntityT[KeyT], scope?: IScope): IResolvedFieldValue<DtoT> | undefined;
}
export {};
