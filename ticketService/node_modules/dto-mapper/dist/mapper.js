"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mapper = void 0;
const hasScope = (field, scope) => {
    return field.scopes == null || (scope != null && field.scopes.includes(scope));
};
const canDeserialize = (field, scope) => {
    return field != null && !field.disableDeserialize && hasScope(field, scope);
};
const canSerialize = (field, scope) => {
    return field != null && !field.disableSerialize && hasScope(field, scope);
};
class Mapper {
    constructor(config) {
        this.config = config;
        this.fieldMap = config.fields.reduce((p, v) => ({
            ...p,
            [v.from]: v,
        }), {});
        this.reverseFieldMap = config.fields.reduce((p, v) => ({
            ...p,
            [v.to]: v,
        }), {});
    }
    deserializeFieldInternal(field, value, scope) {
        if (field.transformer != null) {
            return field.transformer.fromDto(value, scope);
        }
        else {
            return value;
        }
    }
    serializeFieldInternal(field, value, scope) {
        if (field.transformer != null) {
            return field.transformer.toDto(value, scope);
        }
        else {
            return value;
        }
    }
    deserialize(input, scope) {
        if (input == null) {
            return input;
        }
        let inflating;
        if (this.config.entityConstructor) {
            inflating = new this.config.entityConstructor();
        }
        else {
            inflating = {};
        }
        for (const field of this.config.fields) {
            if (canDeserialize(field, scope)) {
                const value = input[field.from];
                inflating[field.to] = this.deserializeFieldInternal(field, value, scope);
            }
        }
        return inflating;
    }
    serialize(input, scope) {
        if (input == null) {
            return input;
        }
        let inflating;
        if (this.config.dtoConstructor) {
            inflating = new this.config.dtoConstructor();
        }
        else {
            inflating = {};
        }
        for (const field of this.config.fields) {
            if (canSerialize(field, scope)) {
                const value = input[field.to];
                inflating[field.from] = this.serializeFieldInternal(field, value, scope);
            }
        }
        return inflating;
    }
    deserializeField(key, input, scope) {
        const field = this.fieldMap[key];
        if (!canDeserialize(field, scope)) {
            return undefined;
        }
        return this.deserializeFieldInternal(field, input, scope);
    }
    serializeField(key, input, scope) {
        const field = this.reverseFieldMap[key];
        if (!canSerialize(field, scope)) {
            return undefined;
        }
        return this.serializeFieldInternal(field, input, scope);
    }
    mapKey(key, scope) {
        const field = this.fieldMap[key];
        if (!canDeserialize(field, scope)) {
            return undefined;
        }
        return field.to;
    }
    unmapKey(key, scope) {
        const field = this.reverseFieldMap[key];
        if (!canSerialize(field, scope)) {
            return undefined;
        }
        return field.from;
    }
    deserializeAndMapField(key, input, scope) {
        const field = this.fieldMap[key];
        if (!canDeserialize(field, scope)) {
            return undefined;
        }
        const value = this.deserializeFieldInternal(field, input, scope);
        return {
            key: field.to,
            value,
        };
    }
    serializeAndUnmapField(key, input, scope) {
        const field = this.reverseFieldMap[key];
        if (!canSerialize(field, scope)) {
            return undefined;
        }
        const value = this.serializeFieldInternal(field, input, scope);
        return {
            key: field.from,
            value,
        };
    }
}
exports.Mapper = Mapper;
