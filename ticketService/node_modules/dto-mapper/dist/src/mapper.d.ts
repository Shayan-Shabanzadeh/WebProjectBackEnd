import { IScope } from './scope';
import { Class } from './utils';
export interface IResolvedFieldValue<T, ClassT> {
    key: keyof ClassT;
    value: T;
}
export interface IMapper<DtoT, EntityT> {
    deserialize(input: DtoT, scope?: IScope): EntityT;
    serialize(input: EntityT, scope?: IScope): DtoT;
    deserializeField<KeyT extends keyof DtoT>(key: KeyT, input: DtoT[KeyT], scope?: IScope): IResolvedFieldValue<DtoT[KeyT], EntityT>;
    serializeField<KeyT extends keyof EntityT>(key: KeyT, input: EntityT[KeyT], scope?: IScope): IResolvedFieldValue<EntityT[KeyT], DtoT>;
}
export declare type ITransformFunction<InT, OutT> = (input: InT) => OutT;
export interface ITransformer<DtoFieldT, EntityFieldT> {
    readonly fromDto: ITransformFunction<DtoFieldT, EntityFieldT>;
    readonly toDto: ITransformFunction<EntityFieldT, DtoFieldT>;
}
export interface IMapperField<DtoKeyT extends keyof DtoT, EntityKeyT extends keyof EntityT, DtoT = any, EntityT = any> {
    readonly from: DtoKeyT;
    readonly to: EntityKeyT;
    readonly scopes?: readonly IScope[];
    readonly transformer?: ITransformer<DtoT[DtoKeyT], EntityT[EntityKeyT]>;
}
export interface IMapperConfig<DtoT, EntityT> {
    readonly dtoConstructor?: Class<DtoT>;
    readonly entityConstructor?: Class<EntityT>;
    readonly fields: IMapperField<keyof DtoT, keyof EntityT, DtoT, EntityT>[];
}
declare type IFieldMap<DtoT, EntityT> = {
    readonly [KeyT in keyof DtoT]?: IMapperField<KeyT, keyof EntityT, DtoT, EntityT>;
};
declare type IReverseFieldMap<DtoT, EntityT> = {
    readonly [KeyT in keyof EntityT]?: IMapperField<keyof DtoT, KeyT, DtoT, EntityT>;
};
export declare class Mapper<DtoT, EntityT> implements IMapper<DtoT, EntityT> {
    readonly config: IMapperConfig<DtoT, EntityT>;
    readonly fieldMap: IFieldMap<DtoT, EntityT>;
    readonly reverseFieldMap: IReverseFieldMap<DtoT, EntityT>;
    constructor(config: IMapperConfig<DtoT, EntityT>);
    deserialize(input: DtoT, scope?: IScope): EntityT;
    serialize(input: EntityT, scope?: IScope): DtoT;
    deserializeField<KeyT extends keyof DtoT>(key: KeyT, input: DtoT[KeyT], scope?: IScope): IResolvedFieldValue<DtoT[KeyT], EntityT>;
    serializeField<T, KeyT extends keyof EntityT>(key: KeyT, input: EntityT[KeyT], scope?: IScope): IResolvedFieldValue<EntityT[KeyT], DtoT>;
}
export {};
