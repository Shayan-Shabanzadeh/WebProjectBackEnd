"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineTransformers = exports.combineTransformFunction = exports.buildMapper = void 0;
const mapper_1 = require("./mapper");
const const_1 = require("./const");
function buildMapper(dtoClass, ignoreNested = false) {
    if (Reflect.getOwnMetadata(const_1.DTO_METADATA, dtoClass) !== true) {
        throw new Error('Missing DTO Decorator on class ' + dtoClass.name);
    }
    const keys = Reflect.getMetadata(const_1.PROPERTIES_METADATA, dtoClass) || [];
    const fields = keys.map((k) => {
        let scopes = Reflect.getMetadata(const_1.SCOPE_METADATA, dtoClass, k) || undefined;
        let to = Reflect.getMetadata(const_1.MAP_TO_METADATA, dtoClass, k) || k;
        const transformers = Reflect.getMetadata(const_1.TRANSFORM_METADATA, dtoClass, k);
        const nested = Reflect.getMetadata(const_1.NESTED_METADATA, dtoClass, k);
        let transformer;
        if (transformers != null && nested != null) {
            throw new Error('A property cannot have @nested and @transform');
        }
        if (transformers) {
            transformer = combineTransformers(transformers);
        }
        else if (nested && !ignoreNested) {
            const clazz = nested.accessor();
            const builtNested = buildMapper(clazz, true);
            transformer = {
                toDto: input => input == null ? null : builtNested.serialize(input),
                fromDto: input => input == null ? null : builtNested.deserialize(input),
            };
        }
        else {
            transformer = undefined;
        }
        return {
            from: k,
            to,
            scopes,
            transformer,
        };
    });
    return new mapper_1.Mapper({ fields });
}
exports.buildMapper = buildMapper;
function combineTransformFunction(functions) {
    if (functions.length === 0) {
        return (data) => data;
    }
    if (functions.length === 1) {
        return functions[0];
    }
    return (input) => {
        let value = input;
        for (let func of functions) {
            value = func(value);
        }
        return value;
    };
}
exports.combineTransformFunction = combineTransformFunction;
function combineTransformers(transformers) {
    return {
        toDto: combineTransformFunction(transformers.map((t) => t.toDto)),
        fromDto: combineTransformFunction(transformers.map((t) => t.fromDto)),
    };
}
exports.combineTransformers = combineTransformers;
