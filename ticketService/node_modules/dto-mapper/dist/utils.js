"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.combineTransformers = exports.combineTransformFunction = exports.buildMapper = void 0;
const mapper_1 = require("./mapper");
const const_1 = require("./const");
const annotation_1 = require("./annotation");
function buildMapper(dtoClass, ignoreNested = false) {
    if (Reflect.getOwnMetadata(const_1.DTO_METADATA, dtoClass) !== true) {
        throw new Error('Missing DTO Decorator on class ' + dtoClass.name);
    }
    const keys = Reflect.getMetadata(const_1.PROPERTIES_METADATA, dtoClass) || [];
    const fields = keys.map((k) => {
        var _a;
        let scopes = Reflect.getMetadata(const_1.SCOPE_METADATA, dtoClass, k) || undefined;
        let to = Reflect.getMetadata(const_1.MAP_TO_METADATA, dtoClass, k) || k;
        const transformers = Reflect.getMetadata(const_1.TRANSFORM_METADATA, dtoClass, k);
        const nested = Reflect.getMetadata(const_1.NESTED_METADATA, dtoClass, k);
        const mode = (_a = Reflect.getMetadata(const_1.ACCESS_MODE_METADATA, dtoClass, k)) !== null && _a !== void 0 ? _a : annotation_1.AccessMode.ALL;
        let transformer;
        if (transformers != null && nested != null) {
            throw new Error('A property cannot have @nested and @transform');
        }
        if (transformers) {
            transformer = combineTransformers(transformers);
        }
        else if (nested && !ignoreNested) {
            const clazz = nested.accessor();
            const builtNested = buildMapper(clazz, true);
            if (nested.many) {
                transformer = {
                    toDto: (input, s) => input == null ? input : input.map((i) => builtNested.serialize(i, s)),
                    fromDto: (input, s) => input == null ? input : input.map((i) => builtNested.deserialize(i, s)),
                };
            }
            else {
                transformer = {
                    toDto: (input, s) => builtNested.serialize(input, s),
                    fromDto: (input, s) => builtNested.deserialize(input, s),
                };
            }
        }
        else {
            transformer = undefined;
        }
        return {
            from: k,
            to,
            scopes,
            transformer,
            disableDeserialize: (mode & annotation_1.AccessMode.WRITE) === 0,
            disableSerialize: (mode & annotation_1.AccessMode.READ) === 0,
        };
    });
    return new mapper_1.Mapper({
        fields,
        dtoConstructor: dtoClass,
    });
}
exports.buildMapper = buildMapper;
function combineTransformFunction(functions) {
    if (functions.length === 0) {
        return (data) => data;
    }
    if (functions.length === 1) {
        return functions[0];
    }
    return (input) => {
        let value = input;
        for (let func of functions) {
            value = func(value);
        }
        return value;
    };
}
exports.combineTransformFunction = combineTransformFunction;
function combineTransformers(transformers) {
    return {
        toDto: combineTransformFunction(transformers.map((t) => t.toDto)),
        fromDto: combineTransformFunction(transformers.map((t) => t.fromDto)),
    };
}
exports.combineTransformers = combineTransformers;
